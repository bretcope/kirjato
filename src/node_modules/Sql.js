"use strict";
/* -------------------------------------------------------------------
 * Require Statements << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

var Config = require('Config');
var debug = require('neo-debug')('Kirj.Sql');
var Pg = require('co-pg')(require('pg.js'));

/* =============================================================================
 * 
 * Sql - Wrapper for SQL commands.
 *  
 * ========================================================================== */

var Sql = module.exports;

/* -------------------------------------------------------------------
 * Private Members Declaration << no methods >>
 * ---------------------------------------------------------------- */


/* -------------------------------------------------------------------
 * Public Members Declaration << no methods >>
 * ---------------------------------------------------------------- */

// code

/* -------------------------------------------------------------------
 * Public Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

/**
 * 
 * @param tran {?Transaction}
 * @param Type
 * @param obj
 * @param [excludes] {string[]} Properties which will be excluded 
 * @returns {*}
 */
Sql.insert = function (tran, Type, obj, excludes)
{
	var mapping = Type.columns;
	var names = Object.keys(mapping);
	
	// id columns are always serial, so we don't insert them
	if (names[0] === 'id')
		names.shift();
	
	var cols = [];
	var vals = [];
	var placeholders = [];
	
	var n;
	for (var i = 0; i < names.length; i++)
	{
		n = names[i];
		if (excludes && excludes.indexOf(n) !== -1)
			continue;
		
		cols.push(mapping[n]);
		vals.push(obj[n]);
		placeholders.push('$' + (i + 1));
	}
	
	var sql = 'insert into '+ Type.tableName +' ('+ cols.join(',') +') values ('+ placeholders.join(',') +');';
	return tran ? tran.query(sql, vals) : Sql.query(sql, vals);
};

Sql.objectFromRow = function (Type, row, prefix)
{
	prefix = prefix ? prefix + '_' : '';
	var t = new Type();
	var cols = Type.columns;
	for (var i in cols)
	{
		t[i] = row[prefix + cols[i]];
	}

	return t;
};

Sql.query = function * (sql, params)
{
	debug(sql);
	if (params)
		debug(params);
	var conn = yield Pg.connect_(Config.sql.connectionString);
	var client = conn[0];
	var done = conn[1];
	
	var result = yield client.query_(sql, params);
	done();
	return result;
};

Sql.setupType = function (Type, table)
{
	Type.tableName = table;
	Type.getColumnList = getSqlColumnListFunction(Type);
	Type.prototype.getColumnValues = getSqlColumnValuesFunction(Type);
};

/**
 * Begins a new transaction and returns it.
 * @returns {Transaction}
 */
Sql.transaction = function * ()
{
	var t = new Transaction();
	yield t.begin();
	return t;
};

/**
 * 
 * @param tran {?Transaction}
 * @param Type
 * @param obj
 * @param [excludes] {string[]}
 * @param [includes] {string[]}
 * @returns {*}
 */
Sql.update = function (tran, Type, obj, excludes, includes)
{
	var mapping = Type.columns;
	var keys = Object.keys(mapping);
	
	var pk = keys.shift();
	var names;
	if (includes instanceof Array)
	{
		names = includes.filter(function (n) { return n !== pk; });
	}
	else
	{
		names = keys;
	}
	
	if (excludes instanceof Array)
	{
		names = names.filter(function (n) { return excludes.indexOf(n) === -1; });
	}
	
	var sets = [];
	var params = [];
	var i = 0;
	var n;
	while (i < names.length)
	{
		n = names[i];
		sets.push(mapping[n] +'=$' + (i++));
		params.push(obj[n]);
	}
	
	var sql = 'update '+ Type.tableName +' set '+ sets.join(',') +' where '+ pk +'=$'+ i +';';
	params.push(obj[pk]);

	return tran ? tran.query(sql, params) : Sql.query(sql, params);
};

/* -------------------------------------------------------------------
 * Private Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

/**
 *
 * @param Type
 * @returns {Object.<string, string>}
 */
function getSqlColumnMap (Type)
{
	var t = new Type();
	var names = Object.keys(t);
	var n, snake;
	var columns = {};
	var replacer = function (match) { return '_' + match.toLowerCase(); };
	for (var i = 0; i < names.length; i++)
	{
		n = names[i];
		if (typeof t[n] === 'function')
			continue;

		// convert from camel case to snake case
		snake = n.replace(/[A-Z]+/g, replacer);
		columns[n] = snake;
	}

	return columns;
}

function getSqlColumnListFunction (Type)
{
	Type.columns = getSqlColumnMap(Type);
	var colVals = [];
	for (var i in Type.columns)
		colVals.push(Type.columns[i]);

	var cache = {};
	var len = colVals.length;

	return function (prefix)
	{
		if (cache.hasOwnProperty(prefix))
			return cache[prefix];

		var cols;
		if (!prefix)
		{
			cols = colVals;
		}
		else
		{
			cols = new Array(len);
			for (var i = 0; i < len; i++)
			{
				cols[i] = prefix + '.' + colVals[i] + ' ' + prefix + '_' + colVals[i];
			}
		}

		return cache[prefix] = cols.join(',');
	};
}

function getSqlColumnValuesFunction (Type)
{
	var cols = Object.keys(Type.columns);
	var len = cols.length;
	return function ()
	{
		/* jshint validthis: true */
		var vals = new Array(len);
		for (var i = 0; i < len; i++)
		{
			vals[i] = this[cols[i]];
		}

		return vals;
	};
}

/* =============================================================================
 * 
 * Sql.Transaction Class
 *  
 * ========================================================================== */

Sql.Transaction = Transaction;

function Transaction ()
{
	this.client = null;
	this.open = false;
	Object.defineProperty(this, '__done', { value: null, writable: true });
}

/* -------------------------------------------------------------------
 * Public Methods << Keep in alphabetical order >>
 * ---------------------------------------------------------------- */

Transaction.prototype.begin = function * ()
{
	var conn = yield Pg.connect_(Config.sql.connectionString);
	this.client = conn[0];
	this.__done = conn[1];

	debug('Beginning transaction');
	var result = yield this.client.query_('BEGIN');
	this.open = true;
	return result;
};

Transaction.prototype.commit = function * ()
{
	debug('Committing transaction');
	try
	{
		this.open = false;
		var result = yield this.client.query_('COMMIT');
		this.__done();
		return result;
	}
	catch (ex)
	{
		this.__done(ex);
		throw ex;
	}
};

Transaction.prototype.query = function * (sql, params)
{
	debug(sql);
	if (params)
		debug(params);
	return yield this.client.query_(sql, params);
};

Transaction.prototype.rollback = function * ()
{
	debug('Rolling back transaction');
	try
	{
		this.open = false;
		var result = yield this.client.query_('ROLLBACK');
		this.__done();
		return result;
	}
	catch (ex)
	{
		this.__done(ex);
		throw ex;
	}
};
